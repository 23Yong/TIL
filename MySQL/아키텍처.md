# MySQL 아키텍처 (1)

## 학습할 것
- MySQL 엔진 아키텍처
    - 구조와 MySQL엔진, 스토리지 엔진
- MySQL 스레딩 구조
    - 포그라운드 스레드와 백그라운드 스레드
- 메모리 할당 및 사용 구조
    - 글로벌 메모리 영역과 로컬 메모리 영역
- 쿼리 실행 구조


## MySQL 엔진 아키텍처

![](/img/MySQL_Architecture.png)

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.

### 스토리지 엔진
MySQL 엔진은 주어진 SQL을 처리하거나 최적화하는 부분을 담당하고, 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어들인다.

MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 테이블이 사용할 스토리지 엔진을 지정하면 모든 읽기나 변경작업은 스토리지 엔진이 처리한다.

### 핸들러 API
MySQL 엔진의 쿼리 실행기에서 데이터를 읽거나 쓸 때는 각 스토리지 엔진에 요청을 보내는데 이를 `핸들러 요청`이라 하고, 여기서 사용되는 API를 `핸들러 API`라고 한다.

## MySQL 스레딩 구조
MySQL은 프로세스 기반이 아닌, 스레드 기반으로 동작을 하고, 크게 포그라운드 스레드와 백그라운드 스레드 두 가지로 구분할 수 있다.

### 포그라운드 스레드 (클라이언트 스레드)
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재한다. MySQL 서버에서는 클라이언트 커넥션의 요청을 처리하기 위해 스레드가 하나씩 할당된다. 각 스레드는 요청을 처리하고 스레드 캐시에 반납되는데, 이때 스레드 캐시에 일정 개수 이상의 스레드가 대기하고 있다면 스레드 캐시에 넣지 않고 스레드를 종료시켜 스레드 캐시에 일정 개수의 스레드만 존재하게 한다. 이때 스레드 캐시에 존재할 수 있는 최대 스레드의 수는 `thread_cached_size` 시스템 변수로 설정한다. 

MySQL 포그라운드 스레드는 데이터를 캐시나 데이터 버퍼에서 읽어오는데, 데이터가 캐시나 데이터 버퍼에 존재하지 않는다면 디스크에서 직접 값을 읽어와 작업을 처리한다.
MyISAM 엔진의 경우 포그라운드 스레드가 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만 InnoDB의 경우 포그라운드 스레드는 캐시나 데이터 버퍼까지만 처리하고, 나머지 버퍼로부터부터 디스크까지 쓰는 작업은 백그라운드 스레드가 담당한다.

![](/img/MySQL_foregroundthread.png)

### 백그라운드 스레드
InnoDB는 다음과 같은 작업들이 백그라운드 스레드로 처리된다.
- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

중요한 것은 로그 스레드(Log thread)와 쓰기 스레드(write thread)이다. 

일반적인 상용 RDBMS는 쓰기 작업을 버퍼링해서 일괄적으로 처리하는 기능을 지원하는데, InnoDB또한 이러한 방식으로 처리한다. 일괄적으로 처리하기 떄문에 InnoDB의 경우 UPDATE, DELETE, INSERT 쿼리로 데이터가 변경될 떄까지 기다리지 않아도 된다.

![MySQL 스레딩 모델](/img/MySQL_threadingmodel.png)
[MySQL 스레딩 모델]

## 메모리 할당 및 사용 구조
MySQL에서 사용되는 메모리 영역은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 글로벌 메모리 영역과 로컬 메모리 영역은 MySQL의 스레드가 메모리 영역을 공유해서 사용하는 공간인지 여부에 따라서 구분된다.

### 글로벌 메모리 영역

- MySQL이 시작되면서 운영체제에 의해 할당된다.
- 일반적으로 클라이언트 수와 무관하게 하나만 할당한다.
- 필요에 따라 두 개 이상이 할당 받을 수는 있지만, 모든 메모리 영역은 모든 스레드에 의해 공유된다.
- 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB와 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

### 로컬 메모리 영역

- MySQL상의 포그라운드 스레드(클라이언트 스레드)가 쿼리를 처리하는데 사용하는 영역
- 포그라운드 스레드 별로 하나씩 할당되며, 절대 공유되지 않는다.
- 각 쿼리의 용도별로 필요할 때만 할당되고 필요하지 않으면 MySQL이 할당조차도 하지 않을 수 있다.
    - 소트 버퍼나 조인 버퍼같은 경우 할당조차 하지 않음.
- 커넥션이 유지되는 동안 할당되는 공간도 있고 쿼리가 실행될 때만 할당되고 다시 해제하는 공간이 있다.
    - 커넥션 -> 커넥션 버퍼, 결과 버퍼
    - 쿼리 -> 소트 버퍼, 조인 버퍼
- 대표적인 로컬 메모리 영역
    - 정렬 버퍼
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼


## 쿼리 실행 구조

![](/img/MySQL_Query.png)

위는 MySQL에서 쿼리를 실행할 때의 구조를 간략하게 표현한 그림이다. 각 기능별로 알아보자.

### 쿼리 파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조를 만들어 내는 작업이다.
- 쿼리 문법 오류는 여기서 발견되고 사용자에게 오류메시지를 전달한다.

### 전처리기
- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는지 확인한다.
- 실제 존재하지 않거나 권한상 사용할 수 없는 토큰은 여기서 걸러진다.

### 옵티마이저
- 사용자의 쿼리를 가장 싼 비용으로 가장 빠르게 처리할지를 결정하는 역할.

### 실행엔진
만들어진 계획대로 핸들러에게 요청하고 핸들러로부터 받은 요청의 결과를 또 다른 핸들러의 입력으로 연결하는 역할을 수행한다.

예를 들어 이해하자. 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 했다고 결정했다.
1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 WHERE절에 일치하는 레코드를 읽어오라고 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

### 핸들러(스토리지 엔진)
MySQL서버의 가장 밑단에서 MySQL 실행엔진의 요청에 따라 디스크로부터 데이터를 읽어오고 쓰는 역할을 한다. 핸들러는 결국 스토리지 엔진을 의미한다.

## 참고 자료
[Real MySQL 8.0 1권](http://www.yes24.com/Product/Goods/103415627)