# 인덱스

## 순차 I/O, 랜덤 I/O
HDD의 경우 랜덤 I/O는 HDD의 플래터(원판)를 돌려서 읽어야 할 데이터가 있는 곳으로 디스크 헤더를 이동시켜 데이터를 읽는 것을 말한다. 그런데 순차 I/O도 이런 작업과정은 동일하다. 그러면 어떤 차이가 있는 것일까?

우리가 어떤 3개의 페이지를 읽고 이를 디스크에 기록해야 한다고 가정했을 때 순차 I/O와 랜덤 I/O의 차이를 보자.<br>
순차 I/O는 읽어들인 3개의 페이지를 기록하기 위해 1번의 시스템 콜이 요청되지만, 랜덤 I/O의 경우 3번의 시스템 콜이 요청된다. 즉, 순차 I/O의 경우 디스크에 기록하기 위해 헤드를 1번 움직였고 랜덤 I/O는 디스크에 기록하기 위해 헤드를 3번 움직였다는 소리이다.

디스크에 데이터를 쓰고 읽는데 소요되는 시간은 헤드를 움직이는 시간에 의해 결정이 되는데 위의 경우 순차 I/O가 랜덤 I/O 보다 약 3배 정도 빠르다고 할 수 있다. 

그런데 디스크 원판을 가지지 않는 SSD의 경우 순차 I/O나 랜덤 I/O나 속도 차이가 없을 것이라 생각할 수 있지만, 실제로는 그렇지 않다. 

## 인덱스
DBMS가 데이터메이스의 모든 테이블을 검색해서 원하는 레코드를 얻으려면 시간이 오래걸린다. 이를 위해 컬럼 값과 해당 레코드가 주소된 데이터를 key-value 형식의 데이터로 삼아 인덱스를 만들어 둔다. 만약 이런 인덱스의 양이 많아지면 원하는 데이터를 얻기 위한 시간이오래 소요된다. 이를 위해 인덱스를 정렬해서 저장을 한다.

이처럼 인덱스는 컬럼의 값을 이용해 항상 정렬된 상태를 유지한다. 그렇기 떄문에 데이터를 저장할 떄마다 항상 정렬 동작을 수행해야 한다. 그래서 `UPDATE`, `INSERT`, `DELETE`에 대한 수행속도는 느리다. 하지만 `SELECT` 연산은 매우 빠르게 처리할 수 있다.

결론적으로 DBMS에서 인덱스는 `SELECT`의 성능을 위해 나머지 기능을 희생시킨 기능이다. 

인덱스를 역할별로 구분하면 다음과 같다.
- 프라이머리 키 (Primary Key)
- 보조 키 (Secondary Index)

> 프라이머리 키는 레코드를 대표하는 컬럼으로 만들어진 인덱스이다. 
> 프라이머리 키를 제외한 모든 인덱스는 세컨더리 인덱스라고 불린다.

또 인덱스를 저장 방식(알고리즘)으로 분류할 경우 다음과 같다.
- B-Tree 인덱스
- Hash 인덱스

데이터의 중복 여부로 분리를 하자면 다음과 같다.
- 유니크 인덱스 (Unique Index)
- 유니크 하지 않은 인덱스 (Non-Unique Index)

인덱스의 유니크 여부는 단순히 값이 1개만 존재하는지 아닌지에 대한 것을 의미하지만, 옵티마이저에게는 다르다. 유니크 인덱스에 대해 동등 조건으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 이상 레코드를 찾지 않아도 되는 것을 의미한다.

## 참고 자료
[Real MySQL 8.0 1권](http://www.yes24.com/Product/Goods/103415627)