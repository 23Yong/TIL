# 스프링 AOP

## OOP의 한계
객체지향 프로그래밍(OOP)에서 애플리케이션을 설계할 때 책임과 관심사에 따라 클래스를 분리하게 된다. SOLID원칙에 따라 각 클래스는 하나의 책임만을 가지고 있고, 클래스를 변경하는 이유도 한 가지여야 한다. 

하지만 객체지향 프로그래밍 원칙에 충실히 애플리케이션을 설계한다하더라도 아래 그림과 같은 문제가 발생할 수 있다.
![](/img/횡단관심사.png)

여러 곳에서 공통된 부가 기능이 여러 클래스에 걸쳐 사용되고 있다. 이렇게 애플리케이션 전반에 걸쳐 흩어져있는 공통된 기능을 횡단 관심사(cross-cutting concerns)라고 한다. 그런데 이런 부가기능을 여러 곳에서 적용하는 것은 번거롭고 유지보수가 쉽지 않다. 

## AOP
부가 기능을 핵심 기능에서 분리하고 한 곳에서 관리한다, 부가 기능을 어디에 적용할지 결정한다. 이와 같이 두 개의 기능(한 곳에서 관리, 어디에 적용할지 선택)을 합해서 하나의 모듈로 만들었는데 이를 `Aspect`라 한다. 애플리케이션을 바라보는 관점을 하나하나의 횡단 관심사에 맞추는 것이다. 이렇게 `Aspect`를 사용한 프로그래밍 방식을 관점 지향 프로그래밍 AOP(Aspect Oriented Programming)이라고 한다. 

참고로 AOP는 OOP를 대체하는 기법이 아닌, 핵심 기능과 부가 기능을 분리하는 등 OOP를 보완하는 개념이다. 

## AOP 적용 방식
AOP를 사용하면 핵심 기능과 부가 기능이 코드상 완전히 분리되어 나타나게 된다. 그렇다면 AOP를 어떻게 적용할 수 있을까? 크게 3가지 방법이 존재한다.
- 컴파일 시점
- 클래스 로딩 시점
- 런타임 시점 (프록시)

### 컴파일 시점
`.java`를 컴파일 해 `.class`로 바꾸는 시점에 부가 기능을 추가할 수 있다. 

이때는 AspectJ에서 제공하는 특별한 컴파일러를 사용해야 한다. 쉽게 이해하자면 컴파일 시점에 부가 기능 로직이 담겨있는 코드가 핵심 기능이 있는 코드에 붙어 컴파일된다고 이해하면 된다. AspectJ 컴파일러는 Aspect를 확인해 해당 클래스가 적용 대상인지 확인하고, 적용 대상인 경우 부가 기능을 적용한다.

참고로 이렇게 원본 로직에 부가 로직이 추가되는 것을 위빙(Weaving)이라고 한다.

- 단점
    - 특별한 컴파일러가 필요하다는 점과 복잡하다는 것이다.


### 클래스 로딩 시점
자바 애플리케이션을 실행할 때 `.class`파일이 JVM 내부의 클래스 로더에 보관하게 된다. 이때 중간에서 `.class`파일을 조작해서 JVM 클래스 로더에 올릴 수 있다. 이 시점에 `Aspect`를 적용하는 것을 *로드 타임 위빙*이라한다.

- 단점
    - 로드 타임 위빙은 자바를 실행할 때 특별한 옵션(`java -javaagent`)을 통해 클래스 로더 조작기를 지정해야 한다. 
    이 부분이 번거롭고 운영하기 어렵다.

### 런타임 시점 (프록시)
런타임 시점에 스프링과 같은 컨테이너의 도움을 받고 프록시와 DI, 빈 포스트 프로세서를 사용해 프록시 방식의 AOP를 사용해 스프링 빈에 부가 기능을 적용할 수 있다.

- 스프링이 빈 객체를 생성한다.
- 빈 객체를 스프링 컨테이너에 등록하기 전 모든 Advisor 빈을 조회해 해당 빈이 적용 대상인지 확인한다.
- 적용 대상이라면 빈을 프록시 빈으로 교체해 스프링 빈 저장소에 등록한다.

![](/img/런타임AOP.png)

### 정리
- 컴파일 시점, 클래스 로딩 시점
    - 실제 대상 코드에 `Aspect`를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접 사용해야 한다.
- 런타임 시점
    - 실제 대상 코드는 유지되지만, 프록시를 통해 부가 기능이 적용된다. 따라서 항상 프록시를 통해 부가 기능이 호출된다. 스프링 AOP는 이 방식을 사용한다.
    

## AOP 적용 위치
AOP는 다음과 같이 다양한 위치에 적용할 수 있다. 
- 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행

이렇게 AOP를 적용할 수 있는 지점을 조인 포인트(Join Point)라고 한다. 

컴파일 시점, 클래스 로딩 시점에 AOP를 적용하는 것은 바이트코드를 실제로 조작하기 때문에 모든 지점에 AOP적용이 가능하다.

하지만 런타임 시점에 AOP를 적용하는 것은 프록시를 이용하기 떄문에 일반 메서드 실행 시점에만 AOP를 적용할 수 있다. 
- 프록시는 메서드 오버라이딩 방식으로 동작을 하기 때문에 생성자나 static 메서드, 필드 값 접근에는 적용할 수 없다.
- 위의 이유로 스프링 AOP의 조인 포인트는 메서드 실행으로 제한된다.
- 프록시 방식을 이용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP를 적용할 수 있다.

## AOP 용어 정리
- 조인 포인트(Join Point)
    - 어드바이스가 적용될 수 있는 위치, 생성자나 static 메서드 접근, 필드 값 접근 같은 프로그램 실행 중 지점
    - 스프링 AOP는 프록시 방식을 이용하기 때문에 조인 포인트는 항상 메서드 실행 시점이다.

- 포인트컷(Pointcut)
    - 조인 포인트 중 어드바이스가 적용될 위치를 식별하는 기능
    - 주로 AspectJ 표현식을 사용해 지정한다.
    - 프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트 컷으로 선별 가능

- 타겟(Target)
    - 어드바이스를 받는 객체, 포인트 컷으로 결정된다.

- 어드바이스(Advice)
    - 부가기능
    - Around(주변), Before(전), After(후)와 같이 다양한 어드바이스가 존재한다.

- 애스팩트(Aspect)
    - 어드바이스 + 포인트컷을 모듈화한 것이다.
    - 여러 어드바이스와 포인트컷이 존재한다.

- 어드바이저(Advisor)
    - 하나의 어드바이스와 하나의 포인트컷으로 구성된다.
    - 스프링 AOP에서만 사용되는 특별한 용어

- 위빙(Weaving)
    - 포인트컷으로 결정한 타겟의 조인포인트에 어드바이스를 적용하는 것
    - AOP적용을 위해 애스펙트를 객체에 연결한 상태

- AOP 프록시
    - AOP 기능을 구현하기 위해 만든 프록시 객체
    - 스프링에서는 JDK 동적 프록시또는 CGLIB 프록시

## 참고 자료

[인프런 - 스프링 핵심원리_고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8/dashboard)