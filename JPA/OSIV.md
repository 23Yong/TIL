# OSIV

## 트랜잭션 범위의 영속성 컨텍스트
기본적으로 스프링 컨테이너는 트랜잭션과 영속성 컨텍스트의 생존 범위를 동일하게 하는 전략을 취한다.<br>
또한 다른 곳에서 엔티티 매니저를 사용하더라도 같은 트랜잭션 내에 있으면 동일한 영속성 컨텍스트를 사용한다.<br>
즉, 다른 트랜잭션 범위에 있으면 다른 영속성 컨텍스트를 사용한다는 말이다.

보통 우리는 서비스 계층에서 `@Transactional`을 통해 트랜잭션을 시작한다. 그리고 서비스 계층이 끝나는 지점에서 트랜잭션을 종료하게 된다. 따라서 컨트롤러나 뷰 같은 프레젠테이션 계층에서는 조회한 엔티티들이 준영속 상태가 된다.<br>
문제는 이 프레젠테이션 계층에서 조회한 엔티티를 지연로딩하려고 할 때이다. <br>
이 프록시 객체를 사용하려고 할 때 프록시 객체가 초기화 되어있지 않다면, 영속성 컨텍스트에 실제 엔티티를 요청하게 되고 영속성 컨텍스트가 DB에서 데이터를 조회해 엔티티를 생성, 반환하게 된다. <br>
그런데 트랜잭션이 종료되었으니 영속성 컨텍스트가 없고 지연 로딩을 할 수 없어 `LazyInitializationException` 예외가 발생한다.

이때 프레젠테이션 계층에서도 영속성 컨텍스트를 사용할 수 있도록 해주는 것이 OSIV이다. OSIV 옵션을 켜두게 되면 영속성 컨텍스트를 사용해 프레젠테이션 계층에서도 엔티티를 지연 로딩할 수 있다.

## 과거 OSIV : 요청 당 트랜잭션
위에서 언급했듯이 프레젠테이션 계층에서도 영속성 컨텍스트를 사용할 수 있도록 하는 것이 OSIV의 핵심이다.<br>
과거 OSIV는 클라이언트의 요청이 서블릿 필터나 스프링 인터셉터로 들어오면 그 시점부터 트랜잭션을 시작하고 요청이 종료되면 트랜잭션을 함께 종료하는 방법을 선택했다. 

그러나 이런 방법은 트랜잭션이 프레젠테이션 계층까지 열려있어, 뷰에서도 데이터의 변경이 가능하다는 점이다.<br>
서비스 계층같이 비즈니스 로직이 있는 곳에서 데이터를 변경하는 것은 당연하지만, 프레젠테이션 계층에서 데이터가 변경되면 데이터베이스까지 영향이 가 애플리케이션 유지 보수가 힘들어진다. 

## 스프링 OSIV : 비즈니스 계층 트랜잭션
위에서의 문제 때문에 현재 스프링 프레임워크가 제공하는 OSIV는 비즈니스 계층에서 트랜잭션을 사용한다.<br>

클라이언트의 요청이 들어오게 되면 영속성 컨텍스트를 생성하되, 트랜잭션은 시작하지 않는다. <br>
요청이 서비스 계층까지 들어와야 앞에서 생성했던 영속성 컨텍스트에 트랜잭션이 시작하게 된다. <br>
요청을 모두 처리하고 JPA가 영속성 컨텍스트를 플러시하면서 트랜잭션이 종료된다. 이때 영속성 컨텍스트는 종료하지 않는다.
이후 클라이언트의 요청이 끝날 때 영속성 컨텍스트를 종료하게 된다.

이렇게 트랜잭션이 종료되도 영속성 컨텍스트는 유지되기 때문에 프레젠테이션 계층에서 엔티티를 조회할 수 있는 것이다.

> 참고로 트랜잭션 없이 엔티티를 조회하는 것을 트랜잭션 없이 읽기(Nontransactional read)라고 한다.<br>

## 영속성 컨텍스트가 유지되고 있을 때 데이터의 변경이 가능할까?
```java
public class MemberController {

    public String viewMember(Long id) {
        Member member = memberService.getMember(id);
        member.setName("newMember");
    }
}
```
위의 코드에서 프레젠테이션 계층에서 엔티티의 데이터 변경을 시도하고 있다.<br>
영속성 컨텍스트가 유지되고 있기 때문에 더티체킹이 발생해 데이터가 변경될 것 같지만 아니다.<br>

1. 영속성 컨텍스트의 변경 내용을 반영하려면 영속성 컨텍스트를 플러시 해야한다.<br>
영속성 컨텍스트의 플러시는 트랜잭션이 커밋될 때 발생하게 되는데 이미 서비스 계층에서 트랜잭션이 종료되었기 때문에 플러시 되지 않는다.<br>
그리고 스프링 OSIV 서블릿 필터나 OSIV 스프링 인터셉터는 요청이 끝나면 영속성 컨텍스트를 플러시 하지 않고 `em.close()`만 호출한다.
2. 위의 코드에서 `em.flush()`를 호출해도 트랜재견 범위 밖이기 때문에 `TransactionRequiredException` 예외가 발생한다.


## OSIV 기본 설정
![](/img/OSIV.png)

지금까지 OSIV를 몰라도 엔티티를 조회할 수 있었던 이유는 open-in-view 옵션이 디폴트 값으로 enabled 되었다는 것을 확인할 수 있다.

## OSIV의 문제
지금까지 OSIV를 보면 장점밖에 없어 보인다. <br> 
그런데, OSIV가 유지되고 있으면 사용자의 요청에 응답할 때까지 데이터베이스 커넥션을 가지고 있게 된다.<br>
따라서 실시간 트래픽이 중요한 애플리케이션의 경우에는 데이터베이스 커넥션이 계속 유지되고 있어 커넥션이 부족하게 되는 상황이 발생할 수 있다. 

이를 해결하기 위해서는 OSIV 옵션을 꺼두고 커맨드와 쿼리를 분리해야 한다. <br>
CommandService와 QueryService를 따로 두어 비즈니스 로직은 CommandService에, 화면이나 API에 맞춘 서비스는 QueryService에 두고 QueryService에 @Transactional(readOnly = true)를 설정하면<br> 
서비스 계층에서 트랜잭션을 사용하고 있기 떄문에 문제가 없다.

## 참고 자료
[자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233)

[실전! 스프링 부트와 JPA활용2 - API개발과 성능 최적화](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94/dashboard)