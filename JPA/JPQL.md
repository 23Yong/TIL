# JPQL

데이터를 조회하는데 있어서 EntityManager.find()나 객체 그래프 탐색을 통해서 엔티티를 조회할 수는 있다. 하지만 나이가 30살 이상인 회원을 모두 검색하고 싶다면 좀 더 복잡한 방법이 필요하다. 모든 회원을 메모리에 올려두고 거기서 30살 이상인 회원을 검색하는 것은 현실성이 없기 때문이다. 

테이블이 아닌 객체를 대상으로 검색하는 방법이 필요한데, 이를 해결하기 위한 것이 JPQL이다.
JPQL은 다음과 같은 특징을 가지고 있다.
- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다.
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.

## 영속성 컨텍스트와 JPQL
JPQL을 통해 엔티티를 조회하면 영속성 컨텍스트에서 관리가 된다. 하지만 엔티티가 아니면 관리가 되지 않는다. 
예를 들어 임베디드 타입은 조회에서 값을 변경해도 영속성 컨텍스트가 관리하지 않기 때문에 변경 감지에 의한 수정이 발생하지 않는다. 물론 엔티티를 조회하면 해당 엔티티가 가지고 있는 임베디드 타입은 수정된다.
결국, 조회한 엔티티만 영속성 컨텍스트가 관리한다는 것이다.

### JPQL로 조회한 엔티티와 영속성 컨텍스트
책에 있는 예를 보면 영속성 컨텍스트에 회원1이 이미 있는데 JPQL로 회원1을 조회하면 어떻게 될 것인지를 알려주고 있다.

```java
em.find(Member.class, "member1");   // 회원 1 조회

List<Member> resultList = em.createQuery("select m from Member m", Member.class)
                    .getReultList();
```
결론부터 얘기하자면 JPQL로 쿼리를 날려 데이터베이스에서 조회한 엔티티가 영속성 컨텍스트에 있으면 조회한 결과를 버리고 영속성 컨텍스트에 있던 엔티티를 반환한다.

![](/img/JPQL_1.png)
![](/img/JPQL_2.png)
그림을 보며 이해하자.
1. JPQL을 사용해 조회를 요청한다.
2. JPQL은 SQL로 변환되어 DB를 조회한다.
3. 조회한 결과와 영속성 컨텍스트와 비교한다.
4. 식별자 값을 기준으로 member1은 이미 영속성 컨텍스트에 있기 때문에 버리고 기존에 있던 member1 엔티티가 반환대상이 된다.
5. 식별자 값을 기준으로 member2는 영속성 컨텍스트에 없기 때문에 영속성 컨텍스트에 추가한다.
6. 쿼리 결과인 member1, member2가 반환된다. 여기서 member1은 쿼리 결과가 아닌 영속성 컨텍스트에 있던 엔티티다.

그런데 왜 영속성 컨텍스트에 있으면 기존 엔티티를 반환할까?
다음과 같은 경우를 생각해보자.
1. 새로운 엔티티를 영속성 컨텍스트에 하나 더 추가한다.
2. 기존 엔티티를 새로 검색한 엔티티로 대체한다.
3. 기존 엔티티는 그대로 두고 새로 검색한 엔티티를 버린다.

1번은 중복된 식별자를 가진 엔티티를 관리할 수 없기 때문에 안된다.
2번은 맞는 것 같지만, 영속성 컨텍스트에 수정 중인 데이터가 사라질 수 있기 때문에 위험하다.
영속성 컨텍스트는 엔티티의 동일성을 보장한다. 따라서 3번으로 동작하게 된다.

### find() VS JPQL
EntityManager의 find()메서드는 엔티티를 영속성 컨텍스트에 먼저 찾고 없으면 데이터베이스를 조회한다. 하지만 JPQL은 항상 데이터베이스에 SQL을 실행해서 결과를 조회한다. 즉, 데이터베이스를 먼저 조회한다.

여기까지 JPQL의 특징을 정리해보자.
- JPQL은 항상 데이터베이스를 조회한다.
- JPQL로 조회한 엔티티는 영속 상태다.
- JPQL은 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.

## JPQL과 플러시 모드
플러시는 영속성 컨텍스트의 변경 내역을 데이터베이스와 동기화하는 것이다. JPA는 플러시가 일어날 때 영속성 컨텍스트의 변경된 엔티티를 찾아서 INSERT, UPDATE, DELETE SQL을 만들어 데이터베이스에 반영한다. 플러시를 호출하기 위해서는 EntityManager의 flush()메서드를 호출할 수 있지만 보통 플러시 모드에 따라 트랜잭션 커밋 직전이나 쿼리 실행 직전에 자동으로 플러시가 호출된다.

플러시모드에는 다음과 같은 옵션이 있다.(Hibernate, JAVA에는 AUTO와 COMMIT만)
- ALWAYS
- AUTO
- COMMIT
- MANUAL

플러시모드는 기본 값이 AUTO라 커밋 직전이나 쿼리 실행 직전에 자동으로 플러시를 호출한다. COMMIT은 커밋 시에만 플러시를 호출하고 쿼리 실행 시에는 플러시를 호출하지 않는다.

## 참고 자료
[자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233)