# 영속성 컨텍스트와 트랜잭션
스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다. 즉, 트랜잭션이 시작하면 영속성 컨텍스트가 시작되고 트랜잭션이 종료되면 영속성 컨텍스트도 같이 종료된다는 것이다. 

보통 트랜잭션을 시작하기 위해서는 서비스 계층에서 `@Transactional`애노테이션을 달아주어 트랜잭션을 시작한다. 이 애노테이션이 있으면 호출한 메서드가 시작되기 전에 스프링 트랜잭션 AOP가 먼저 동작된다. 
스프링 트랜잭션 AOP가 메서드를 호출하기 직전 트랜잭션을 시작하고 메서드가 종료되면 트랜잭션을 종료한다. 물론 정상 종료가 되면 커밋을, 예외가 발생하면 트랜잭션을 롤백하고 종료한다.

이때 트랜잭션이 커밋될 때 JPA는 영속성 컨텍스트의 내용을 데이터베이스에 플러시해서 변경 내용을 데이터베이스에 반영한다. 예외가 발생하면 플러시를 호출하지 않는다.

## 트랜잭션 범위의 영속성 컨텍스트 전략
- 트랜잭션 범위의 영속성 컨텍스트 전략은 다양한 범위에서 엔티티 매니저를 호출해서 사용해도 트랜잭션이 같다면 동일한 영속성 컨텍스트를 사용한다. 즉, 엔티티 매니저가 달라도 트랜잭션이 같으면 동일한 영속성 컨텍스트를 사용하는 것이다.
- 반면 멀티 스레드 환경에서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다. 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. 이는 멀티 스레드 환경에서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르기 때문에 안전하다.

## 준영속 상태와 지연 로딩
트랜잭션 범위의 영속성 컨텍스트 전략에서 트랜잭션은 보통 서비스 계층에서 시작해 서비스 계층이 끝나는 시점에 트랜잭션이 종료되며 영속성 컨텍스트도 종료된다.
이는 컨트롤러나 뷰 같은 프레젠테이션 계층에서는 엔티티가 준영속 상태가 되는 것을 의미한다.

변경 감지(더티 체킹)기능은 영속성 컨텍스트가 살아있는 서비스계층(트랜잭션의 범위)까지만 동작한다. 보통 변경 감지 기능은 서비스 계층에서 비즈니스 로직을 수행하며 발생한다. 단순히 데이터를 보여주는 프레젠테이션 계층에서 변경 감지 기능을 사용할 일은 거의 없다. 프레젠테이션 계층은 데이터를 보여주는데 집중하는 것이 더 보기 좋기 때문에 변경 감지 기능이 동작하지 않는 것은 문제가 되지 않는다.

그런데 준영속 상태의 엔티티의 가장 큰 문제는 지연 로딩 기능이 동작하지 않는다는 것이다. 프록시 상태의 객체를 조회하려 할 때 초기화하기 위해 실제 엔티티 생성을 영속성 컨텍스트에게 요청하고 영속성 컨텍스트가 데이터베이스를 조회해 생성해 프록시 상태의 객체가 해당 엔티티의 참조를 보관 해야 하는데 준영속 상태이기 때문에 영속성 컨텍스트가 닫혀있어 초기화를 할 수 없다는 것이 문제이다. 따라서 `org.hiberate.LazyInitializationException`예외가 발생해 버린다.

이런 문제를 해결하기 위해서는 크게 두 가지 방법이 있다.
1. 뷰가 필요한 엔티티를 미리 로딩
2. OSIV를 사용해 영속성 컨텍스트를 프레젠테이션 계층까지 열어두는 방법

## 참고 자료
[자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233)